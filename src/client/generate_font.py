#!/usr/bin/python3

letters = r"""-a


 XXXX
X   X
X   X
X   X
 XXXX

-A
  X
 X X
X   X
X   X
XXXXX
X   X
X   X

-b
X
X
XXXX
X   X
X   X
X   X
XXXX

-B
XXXX
X   X
X   X
XXXX
X   X
X   X
XXXX

-c


 XXX
X   X
X
X   X
 XXX

-C
 XXX
X   X
X
X
X
X   X
 XXX

-d
    X
    X
 XXXX
X   X
X   X
X   X
 XXXX

-D
XXXX
X   X
X   X
X   X
X   X
X   X
XXXX

-e


 XXX
X   X
XXXXX
X
 XXX

-E
XXXXX
X
X
XXXX
X
X
XXXXX

-f
 XX
X
X
XX
X
X
X

-F
XXXXX
X
X
XXXX
X
X
X

-g


 XXXX
X   X
X   X
X   X
 XXXX
    X
 XXX

-G
 XXX
X   X
X
X  XX
X   X
X   X
 XXX

-h
X
X
XXXX
X   X
X   X
X   X
X   X

-H
X   X
X   X
X   X
XXXXX
X   X
X   X
X   X

-i
X

X
X
X
X
X

-I
XXX
 X
 X
 X
 X
 X
XXX

-j
  X

  X
  X
  X
  X
XX

-J
 XXX
   X
   X
   X
   X
X  X
 XX

-k
X
X
X   X
X  X
XXX
X  X
X   X

-K
X   X
X  X
X X
XXX
X  X
X   X
X   X

-l
X
X
X
X
X
X
 XX

-L
X
X
X
X
X
X
XXXXX

-m


 XX XX
X  X  X
X  X  X
X  X  X
X  X  X

-M
X     X
XX   XX
X X X X
X  X  X
X     X
X     X
X     X

-n


 XxX
X   X
X   X
X   X
X   X

-N
X    X
XX   X
X X  X
X  X X
X   XX
X    X
X    X

-o


 XXX
X   X
X   X
X   X
 XXX

-O
 XXX
X   X
X   X
X   X
X   X
X   X
 XXX

-p


XXXX
X   X
X   X
X   X
XXXX
X
X

-P
XXXX
X   X
X   X
XXXX
X
X
X

-q


 XXXX
X   X
X   X
X   X
 XXXX
    X
    X

-Q
 XXX
X   X
X   X
X   X
X   X
X X X
 XXX
   X
    X

-r


 XXX
X
X
X
X

-R
XXXX
X   X
X   X
XXXX
X  X
X   X
X   X

-s


 XXXX
X
 XXX
    X
XXXX

-S
 XXX
X   X
X
 XXX
    X
X   X
 XXX

-t
X
X
XX
X
X
X
 XX

-T
XXXXX
  X
  X
  X
  X
  X
  X

-u


X   X
X   X
X   X
X   X
 XXX

-U
X   X
X   X
X   X
X   X
X   X
X   X
 XXX

-v


X   X
X   X
X   X
 X X
  X

-V
X   X
X   X
X   X
X   X
X   X
 X X
  X

-w


X     X
X     X
X     X
X  X  X
 XX XX

-W
X     X
X     X
X     X
X  X  X
X  X  X
X  X  X
 XX XX

-x


X   X
 X X
  X
 X X
X   X

-X
X   X
X   X
 X X
  X
 X X
X   X
X   X

-y


X   X
X   X
X   X
 X X
  X
 X

-Y
X   X
X   X
 X X
  X
  X
  X
  X

-z


XXXXX
   X
  X
 X
XXXXX

-Z
XXXXX
    X
   X
  X
 X
X
XXXXX

-!
X
X
X
X
X

X

-"
X X
X X

-#


 # #
#####
 # #
#####
 # #

-$
 XXX
X X X
X X
 XXX
  X X
X X X
 XXX

-%


X   X
   X
  X
 X
X   X

-&
  XX
 X  X
 X  X
  XX
 X X  X
X   X
 XXX X

-'
X
X

-(
  X
 X
X
X
X
 X
  X

-)
X
 X
  X
  X
  X
 X
X

-*

X X X
 XXX
XXXXX
 XXX
X X X

-+

  X
  X
XXXXX
  X
  X

-,






 X
X

--



XXXXX

-.






X

-/
  X
  X
 X
 X
 X
X
X

-0
 XXX
X   X
X  XX
X X X
XX  X
X   X
 XXX

-1
 X
XX
 X
 X
 X
 X
XXX

-2
 XXX
X   X
    X
   X
  X
 X
XXXXX

-3
 XXX
X   X
    X
   X
    X
X   X
 XXX

-4
   X
  XX
 X X
X  X
XXXXX
   X
   X

-5
XXXXX
X
XXXX
    X
    X
X   X
 XXX

-6
 XXX
X   X
X
XXXX
X   X
X   X
 XXX

-7
XXXXX
    X
   X
  X
 X
 X
 X

-8
 XXX
X   X
X   X
 XXX
X   X
X   X
 XXX

-9
 XXX
X   X
X   X
 XXXX
    X
X   X
 XXX

-:


X



X


-;


 X



 X
X

-<

   XX
 XX
X
 XX
   XX


-=


XXXXX

XXXXX

->

XX
  XX
    X
  XX
XX

-?
 XXX
X   X
    X
   X
  X

  X

-@

  XXXX
 X    X
X  XXX X
X X  X X
X X  X X
X  XXXX

-[
XXX
X
X
X
X
X
XXX

-]
XXX
  X
  X
  X
  X
  X
XXX

-\
X
X
 X
 X
 X
  X
  X

-^
  X
 X X

-_







XXXXX

-`
X
 X

-{
  X
 X
 X
X
 X
 X
  X

-}
X
 X
 X
  X
 X
 X
X

-|
X
X
X
X
X
X
X

-~


 X
X X X
   X

"""

ascent = 7
descent = 2
spacing = 1
space_advance = 4
unknown_char_width = 5
fixed_point_multiplier = 16

import re

def median(data):
    return sorted(data)[len(data) // 2]

def header_and_rest(fn, iterable):
    current_header = None
    current_group = None
    for item in iterable:
        header = fn(item)
        if header:
            if current_header:
                yield (current_header, current_group)
            current_header = header
            current_group = []
        else:
            if not current_header:
                raise RuntimeError("Group without header")
            current_group.append(item)
    if current_header:
        yield (current_header, current_group)

def match_header(line):
    match = re.match(r"^-(.)\s*$", line)
    if not match:
        return False
    else:
        return match.group(1)

def line_to_number(line):
    ret = 0
    used = 0
    for i, char in enumerate(line):
        if not char.isspace():
            ret = ret | 1 << i
            used = i + 1

    return (ret, used)

def line_distance(n1, advance1, n2):
    if n1 == 0 or n2 == 0:
        return None

    for i in reversed(range(8)):
        if n1 & (1 << i):
            ret = advance1 - i - 1
            break
    for i in range(8):
        if n2 & (1 << i):
            return ret + i

def kern_pair(glyph1, glyph2):
    numbers1, advance1 = glyph1
    numbers2, advance2 = glyph2

    distances = (line_distance(n1, advance1, n2) for n1, n2 in zip(numbers1, numbers2))
    distances = [d for d in distances if d is not None]

    if not len(distances):
        return 0

    # Calculate weighted mean of d in distances, weighted by 1/d
    weighted_avg_distance = len(distances) / sum(1 / d for d in distances)

    return 1 - weighted_avg_distance

letters_map = {}

letters_map[" "] = ([0] * (ascent + descent), space_advance)

for letter, lines in header_and_rest(match_header, letters.split("\n")):
    numbers, width = zip(*map(line_to_number, lines))
    width = max(width)

    while numbers[-1] == 0:
        numbers = numbers[:-1]
    numbers = list(numbers)

    if letter in letters_map:
        raise RuntimeError("Duplicate letter " + repr(letter))

    if any(number > 255 for number in numbers):
        raise RuntimeError("Letter " + repr(letter) + " is wider than 8 characters")

    if len(numbers) < ascent + descent:
        numbers.extend([0] * (ascent + descent - len(numbers)))
    elif len(numbers) > ascent + descent:
        raise RuntimeError("Letter " + repr(letter) + " is taller than ascent + descent (" + str(ascent + descent) + ")")

    letters_map[letter] = (numbers, width + spacing)

start_symbol = min(ord(letter) for letter in letters_map)
end_symbol = max(ord(letter) for letter in letters_map) + 1

unknown_char = [(1 << unknown_char_width) - 1] * ascent
unknown_char.extend([0] * descent)
letters_map[chr(end_symbol)] = (unknown_char, unknown_char_width + spacing)

for i in range(start_symbol, end_symbol + 1):
    c = chr(i)

    if c not in letters_map:
        raise Exception("Missing letter " + repr(c))

    kernings = []
    for j in range(start_symbol, end_symbol):
        kernings.append(kern_pair(letters_map[c], letters_map[chr(j)]))

    new_advance = letters_map[c][1] + median(kernings)
    new_advance = round(new_advance * fixed_point_multiplier) / fixed_point_multiplier

    letters_map[c] = (letters_map[c][0], new_advance)

print("pub const FIRST_GLYPH: usize = {};".format(start_symbol))
print("pub const GLYPH_COUNT: usize = {};".format(end_symbol - start_symbol + 1))
print("pub const GLYPH_HEIGHT: usize = {};".format(ascent + descent))
print("pub const GLYPH_ASCENT: u32 = {};".format(ascent))
print("pub const GLYPH_SPACING: u32 = {};".format(spacing))
print("pub const GLYPH_FP_MULTIPLIER: u32 = {};".format(fixed_point_multiplier))
print()
print("#[derive(Copy,Clone,Debug)]")
print("pub struct Glyph (pub u8, pub [u8; GLYPH_HEIGHT]);")
print()
print("pub const GLYPHS: [Glyph; GLYPH_COUNT] = [")
for i in range(start_symbol, end_symbol + 1):
    c = chr(i)
    glyph = letters_map[c]
    if glyph[1] > (1 << 8) / fixed_point_multiplier:
        raise RuntimeError("Too large glyph advance for " + repr(c))
    if i == end_symbol:
        c = "Unknown character"

    print("    Glyph(0x{:02x}, [".format(int(glyph[1] * fixed_point_multiplier)) + ", ".join("0x{:02x}".format(number) for number in glyph[0]) + "]), /* {} */".format(c))

print("];")
